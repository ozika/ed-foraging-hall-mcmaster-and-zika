---
title: "Behavioural analysis: All trials"
author: "Ondrej Zika and Sam Hall-McMaster"
date: "2024-06-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(here)
here::i_am(".ed-foraging-root")
#renv::restore(here::here())

renv::load(here::here())

# data set 
# "" = stadnard
# "_alt_cutoff" = alternative cutoff EAT26>=20
data_set = "_alt_cutoff"

required_packages = c("glmmTMB", "car", "parameters", "see", "bayestestR", "dplyr", "lmerTest", "effectsize", "emmeans", "modelbased", "ggpubr", "gtools", "tidyr")
invisible(lapply(required_packages, require, character.only = TRUE))
emmeans::emm_options(pbkrtest.limit = 11000)
adjustment_method = "holm"


```
```{r}
data <- read.csv(here::here( 'anon-data', 'task_data', paste0('full_beh_data',data_set,'.csv')))
data$gender.str <- as.factor(paste0("g", as.character(data$gender)))
data$reward <- as.numeric(data$patch_reward_recieved)
data$logRT <- log(data$RT)
data$log_patch_actions_taken <- log(data$patch_actions_taken)
data <- data %>%
  mutate(decision_type = recode(decision_type, `1` = 0, `2` = 1)) %>% 
  mutate(decision = case_when(decision_type == 0 ~ "stay", decision_type == 1 ~ "leave"))
data<- data[data$RT!=0,]  

# calculate cumulative sum within each patch
data <- data %>%
  mutate(set = cumsum(patch_reward_recieved == 0)) %>%
  group_by(set) %>%
  mutate(cum_reward_patch = cumsum(ifelse(patch_reward_recieved == 0, 0, patch_reward_recieved))) %>%
  ungroup() %>%
  select(-set)
data$cum_reward_patch <- data$cum_reward_patch/100

## add questionnaires data 
qs <- read.csv(here::here( 'anon-data', 'questionnaires', paste0('anonymized_processed_questonnaire_data',data_set,'.csv')))
qs$id <- qs$PROLIFICID
qs <- qs[,c("id", "bmi",  "eat26",  "eat26_oralcontrol", "eat26_dieting", "eat26_bulimia",  "edeq", "cia", "aai", "stait", "bdi",  "iou",  "oci")]
data = merge(data, qs, by=c("id"), all.x = TRUE) # NA's match

# add factor scores
fa.scores <- read.csv(here::here( 'anon-data', 'questionnaires', paste0('factor_scores',data_set,'.csv')))
data = merge(data, fa.scores, by=c("id"),all.x = TRUE) # NA's match

rew <- read.csv(here::here( 'anon-data', 'task_data', paste0('rewards_data',data_set,'.csv')))
rew$total_rewards <- rew$patch_reward_recieved
data = merge(data, rew, by=c("id","travel_time_lvl", "decay_lvl"),all.x = TRUE) # NA's match

data$blk_fac <- factor(data$blk_number, labels=c(1,2,3,4), ordered=TRUE)

linkfunc ="log"
#

```

# Overall Reward 

```{r}
df = data %>%
  group_by(id, group) %>%
  summarise_at(c("reward"), sum, na.rm = TRUE)
df2  <- df %>%
  group_by(group) %>%
  summarise_at(c("reward"), mean, na.rm = TRUE)
df2
```

# Reaction times analysis from each trial
## Descriptives
Here, the main thing is whether the RTs differ by decision type (we already know their RT patterns for leaving-only trials)


### decision
RTs are faster for leave than stay trials
```{r  fig.width=4, fig.height=5}
df = data %>%
  group_by(id, decision) %>%
  summarise_at(c("logRT"), mean, na.rm = TRUE)

g <- ggplot(data = df, aes(y = logRT, fill = decision, x=decision)) +
  geom_point(aes(color = decision), position =   position_jitterdodge(  jitter.width = .15,  dodge.width = 0.777
                                                                                                       ), size = 2, lwd=1, alpha = 0.5, show.legend=FALSE) +
  scale_fill_manual(values = c("darkgreen", "blue", "blue", "lightblue")) + 
  geom_boxplot(inherit.aes = TRUE,  width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=TRUE)   + 
  
  scale_color_manual(values = c("darkgreen", "blue", "blue", "lightblue")) 
g
```

### travel time x reward decay
```{r}
df = data %>%
  group_by(id, decay_fac, travel_time_lvl) %>%
  summarise_at(c("logRT"), mean, na.rm = TRUE)

g <- ggplot(data = df, aes(y = logRT, fill = interaction(decay_fac, travel_time_lvl), x=travel_time_lvl)) +
  geom_point(aes(color = interaction(decay_fac, travel_time_lvl)), position =   position_jitterdodge(  jitter.width = .15,  dodge.width = 0.777
                                                                                                       ), size = 2, lwd=1, alpha = 0.5, show.legend=FALSE) +
  scale_fill_manual(values = c("darkgreen", "darkseagreen", "blue", "lightblue")) + 
  geom_boxplot(inherit.aes = TRUE,  width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=TRUE)   + 
  
  scale_color_manual(values = c("darkgreen", "darkseagreen", "blue", "lightblue")) 
g
```
### travel time x group x decision

decision = leave, travel_time_lvl = long:
 contrast        estimate     SE  df z.ratio p.value
 group1 - group2   -0.201 0.1001 Inf  -2.009  0.0446
 
 only leave long is significant (though it's close)
 
 The main effect of group is pretty close p=0.08
```{r}
df = data %>%
  group_by(id, decision, group, travel_time_lvl) %>%
  summarise_at(c("logRT"), mean, na.rm = TRUE)

g <- ggplot(data = df, aes(y = logRT, fill = interaction(decision, group), x=decision)) +
  geom_point(aes(color = interaction(decision, group)), position =   position_jitterdodge(  jitter.width = .15,  dodge.width = 0.777
                                                                                                       ), size = 2, lwd=1, alpha = 0.5, show.legend=FALSE) +
  scale_fill_manual(values = c("darkgreen", "darkseagreen", "blue", "lightblue")) + 
  geom_boxplot(inherit.aes = TRUE,  width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=TRUE)   + 
  
  scale_color_manual(values = c("darkgreen", "darkseagreen", "blue", "lightblue")) + 
  facet_grid(rows = vars(travel_time_lvl))
g
```
### decision x group x decision

decision = stay, decay_fac = slow:
 contrast        estimate     SE  df z.ratio p.value
 group1 - group2   -0.224 0.1055 Inf  -2.123  0.0338
 
Stay-slow is significant between groups - group 1 is faster when the decay is slow and the decision is to stay

```{r}
df = data %>%
  group_by(id, decision, group, decay_fac) %>%
  summarise_at(c("logRT"), mean, na.rm = TRUE)

g <- ggplot(data = df, aes(y = logRT, fill = interaction(decision, group), x=decision)) +
  geom_point(aes(color = interaction(decision, group)), position =   position_jitterdodge(  jitter.width = .15,  dodge.width = 0.777
                                                                                                       ), size = 2, lwd=1, alpha = 0.5, show.legend=FALSE) +
  scale_fill_manual(values = c("darkgreen", "darkseagreen", "blue", "lightblue")) + 
  geom_boxplot(inherit.aes = TRUE,  width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=TRUE)   + 
  
  scale_color_manual(values = c("darkgreen", "darkseagreen", "blue", "lightblue")) + 
  facet_grid(rows = vars(decay_fac))
g
```


## Stats
In contrast to analyses in the leaving-only trials, here we also include "decision" as a variable of interest (stay/leave)
```{r}

linkfunc ="log"
m1 <- lme4::lmer(data=data, RT ~ decay_fac*travel_time_lvl*group*decision + (1|id))

m1.sl <- lme4::lmer(data=data, RT ~ decay_fac*travel_time_lvl*group*decision + (1+decay_fac+travel_time_lvl+decision|id))


glm1 <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group*decision + (1|id), family = Gamma(link=linkfunc))
glm1.sl <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group*decision + (1+decay_fac+travel_time_lvl+decision|id), family = Gamma(link=linkfunc))
glm1.sl.dc <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group*decision + (1+decay_fac|id), family = Gamma(link=linkfunc))
glm1.sl.tt <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group*decision + (1+travel_time_lvl|id), family = Gamma(link=linkfunc))
glm1.sl.dec <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group*decision + (1+decision|id), family = Gamma(link=linkfunc))

performance::compare_performance( m1, m1.sl, glm1, glm1.sl, glm1.sl.dc, glm1.sl.tt, glm1.sl.dec)#

#
```

### Analysis of winning model

```{r}
car::Anova(glm1.sl)

```

Posthoc: interaction travel time * decay
```{r}

em <- emmeans(glm1.sl, pairwise ~ travel_time_lvl*decay_fac, adjust=adjustment_method)
em
```

```{r}
em <- emmeans(glm1.sl, pairwise ~ group | decision*decay_fac, adjust=adjustment_method)
em
```

travel_time_lvl:group:decision            5.2130  1   0.022418 * 
```{r}
em <- emmeans(glm1.sl, pairwise ~ group | decision*travel_time_lvl, adjust=adjustment_method)
em
```

## RTs as a function of remaining time
NOTE: I removed the decision from the random slopes here - the models were not converging
```{r}
##glm1.sl.1 <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group*decision + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))
#glm1.sl.2 <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group*decision*remaining_time + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))


data$remaining_time_reversed <-   data$remaining_time * (-1)
data$gr <- data$group
# models with speeding up within block
glm1.sl.1 <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*gr + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))
glm1.sl.2 <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*gr*remaining_time_reversed + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))



# models with speeding up within episode
glm2.sl.1 <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*gr*patch_time + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))

#gender.str
performance::compare_performance( glm1.sl.1, glm1.sl.2, glm2.sl.1)#

# models with speeding up effect in block fit much better thatn speeding up within patch

```


```{r}
car::Anova(glm1.sl.2)

#car::Anova(glm2.sl.1)

# three way int decay*gr*patch time
em <- emtrends(glm2.sl.1, pairwise ~ gr | travel_time_lvl , var = "patch_time", adjust=adjustment_method)
em
em <- emtrends(glm2.sl.1, pairwise ~  travel_time_lvl | gr , var = "patch_time", adjust=adjustment_method)
em
em <- emtrends(glm2.sl.1, pairwise ~  travel_time_lvl * gr , var = "patch_time", adjust=adjustment_method)
em
#sl<-modelbased::estimate_slopes(glm2.sl.1, trend = "patch_time", at=c("decay_fac", "gr"), ci = 0.95)
#sl

# gr 1 gets faster within patch in the fast condition 
# gr 2 get slower in the fast reward decay condition over time but faster in the slow decay condition

em2 <- emtrends(glm2.sl.1, pairwise ~ gr | travel_time_lvl*travel_time_lvl , var = "patch_time", adjust=adjustment_method)
em2

#sl<-modelbased::estimate_slopes(glm2.sl.1, trend = "patch_time", at=c( "gr", "decay_fac", "travel_time_lvl"), ci = 0.95)
#sl

```



 

```{r}
car::Anova(glm2.sl.1)
```


group:remaining_time                            39.0090  1  4.219e-10 ***



### Speeding up overall

```{r}
em <- emtrends(glm1.sl.2, pairwise ~ 1 , var = "remaining_time_reversed", adjust=adjustment_method)
em
data$rem_time_q <- gtools::quantcut(as.numeric(data$remaining_time_reversed), q = seq(0,1,0.05))

df <- data %>% 
  group_by(id, rem_time_q) %>% 
  summarise_at(c( "logRT", "remaining_time_reversed"), mean)

g <- ggplot(aes(y = logRT, x = rem_time_q, fill=rem_time_q), data = df) +
  geom_point(alpha=0.2, aes(color=rem_time_q), show.legend = FALSE) +
  geom_boxplot(aes( x=rem_time_q, y=logRT), inherit.aes = FALSE, width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=FALSE)   + 
 #geom_smooth(aes(x = remaining_time, y=logRT), inherit.aes = FALSE, method = lm, formula = y ~ x, se = TRUE, legend=FALSE) +

  scale_fill_manual(values = rep(c("maroon4"), 20))  + 
  scale_color_manual(values = rep(c("maroon4"), 20))  
g

## alternative plot
data$rem_time_q <- gtools::quantcut(as.numeric(data$remaining_time_reversed), q = seq(0,1,0.02))
df <- data %>% 
  group_by(id, group,rem_time_q) %>% 
  summarise_at(c("logRT", "remaining_time_reversed"), mean)

library(ggplot2)
g <- ggplot(aes(y = logRT, x = remaining_time_reversed), data = df) +
  geom_point(alpha=0.2) +
    geom_smooth(method = 'lm', se = TRUE)  + 
  scale_colour_brewer(palette="Set1")  
  #ggtitle("F1 ~ TF1 * wave * Deaths ") 
g
```

### Speeding up by group
$emtrends
 group  remaining_time_reversed.trend       SE  df asymp.LCL asymp.UCL
 group1                     -0.000555 3.73e-05 Inf -0.000628 -0.000482
 group2                     -0.000191 3.36e-05 Inf -0.000257 -0.000125

Results are averaged over the levels of: decay_fac, travel_time_lvl 
Confidence level used: 0.95 

$contrasts
 contrast         estimate       SE  df z.ratio p.value
 group1 - group2 -0.000364 5.03e-05 Inf  -7.244  <.0001

```{r}
em <- emtrends(glm1.sl.2, pairwise ~ gr , var = "remaining_time_reversed", adjust=adjustment_method)
em

data$rem_time_q <- gtools::quantcut(as.numeric(data$remaining_time_reversed), q = seq(0,1,0.05))

df <- data %>% 
  group_by(id, group, rem_time_q) %>% 
  summarise_at(c( "logRT", "remaining_time_reversed"), mean)

g <- ggplot(aes(y = logRT, x = rem_time_q, fill=interaction(group,rem_time_q)), data = df) +
  geom_point(alpha=0.2, aes(color=group), show.legend = FALSE) +
  geom_boxplot( width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=FALSE)   + 
 #geom_smooth(aes(x = remaining_time, y=logRT), inherit.aes = FALSE, method = lm, formula = y ~ x, se = TRUE, legend=FALSE) +

  scale_fill_manual(values = rep(c("maroon4", "dodgerblue"), 20))  + 
  scale_color_manual(values = rep(c("maroon4","dodgerblue"), 20))  
g
```
## Calculate what the "speeding up" effect means in terms of real reaction times
```{r}

data$rem_time_q <- gtools::quantcut(as.numeric(data$remaining_time), q = seq(0,1,0.1))

df <- data %>% 
  group_by( group, rem_time_q) %>% 
  summarise_at(c( "RT", "remaining_time"), mean)
df
```
## Test if there is a difference on first 10% of trials in block
```{r}
df <- data %>% 
  group_by(id, group, rem_time_q) %>% 
  summarise_at(c( "RT", "remaining_time"), mean)
dfloc <- df[df$rem_time_q=="[0.029,43.7]", ]
t.test(dfloc$RT[dfloc$group=="group1"], dfloc$RT[dfloc$group=="group2"] )
```


```{r fig.width=4, fig.height=6}
df <- data %>% 
  group_by(id, group,rem_time_q) %>% 
  summarise_at(c("logRT", "remaining_time"), mean)


library(ggplot2)
g <- ggplot(aes(y = logRT, x = remaining_time, color=group), data = df) +
  geom_point(alpha=0.2) +
    geom_smooth(method = 'lm', se = TRUE)  + 
  scale_color_manual(values = rep(c("maroon4","dodgerblue"), 20))  
  #ggtitle("F1 ~ TF1 * wave * Deaths ") 
g
```
### Remaining time final figure 

```{r fig.width=5.4, fig.height=10}
df <- data %>% 
  group_by(id, group,rem_time_q) %>% 
  summarise_at(c("logRT", "remaining_time"), mean)

df2 <- df %>% 
  group_by(id, group) %>% 
  summarise_at(c("logRT", "remaining_time"), mean)


df2 <- df2 %>%
  mutate(color = case_when(group == "group1" ~ "maroon4", group == "group2" ~ "dodgerblue"))

library(ggplot2)
g <- ggplot(aes(y = logRT, x = remaining_time, color=id), data = df) +
 # geom_point(alpha=0.05, show.legend = FALSE) +
 #   geom_smooth(method = 'lm', se = FALSE, show.legend = FALSE, alpha=0.1)  + 
  #geom_line(stat="smooth", method = "lm", formula = y ~ x,
   #           size = 0.5,      alpha = 0.5, show.legend = FALSE) +
  stat_smooth( geom='line', alpha=0.1, se=FALSE, show.legend = FALSE, method = 'lm', formula = y ~ x) + 
  #stat_smooth(aes(y = logRT, x = remaining_time, color=group), data = df, geom='line', alpha=0.1, se=FALSE, show.legend = FALSE) + 
  scale_color_manual(values = c(c("maroon4","dodgerblue"), df2$color) ) +
  scale_x_reverse() +

  geom_smooth(aes(y = logRT, x = remaining_time, color=group), data = df, method = 'lm', se = TRUE, show.legend = FALSE)   + 
    theme(panel.background = element_blank(),  # Ensure background is fully transparent
        panel.grid.major = element_blank(),   # Remove major grid lines
        panel.grid.minor = element_blank(),  
            axis.line = element_line(color = "black"),  # Add axis lines
    axis.ticks = element_line(color = "black"))  + # Add axis ticks) +
   labs(
    x = "Remaining Time in Block (s)",  # Label for the x-axis
    y = "Log Reaction Time"        # Label for the y-axis
  ) 

  #ylim(-3.2, 0.1) 

  
  #ggtitle("F1 ~ TF1 * wave * Deaths ") 
g

ggsave(
  here::here("output", "rt_speeding_up.pdf"), 
  scale = 1,
  width = 3,
  height = 5,
  units = c("in"),
  dpi = 300)
```
## Linking speeding up effect to the amount of reward (Watch out this is EPISODE)
1) Calculate reward in each episode
2) Calculate speeding up effect within each episode
3) Run a regression and plot them
```{r}

linkfunc="log"
data$unique_episode <- paste0("bl", data$blk_number, "_ep", data$episode)

m <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group + (1+decay_fac+travel_time_lvl+remaining_time|unique_episode/id), family = Gamma(link=linkfunc))



# Get speeding up effect for each episode (while controlling for other vars)
sl<-data.frame(ranef(m)$cond$`id:unique_episode`)
sl$rawvar <- rownames(sl)
sl <- sl %>%
  tidyr::separate(rawvar, into = c("id", "unique_episode"), sep = ":")

# Get rewards for each episode
ep_rewards <- data %>% 
  group_by(id, group,unique_episode, blk_number, episode) %>% 
  summarise_at(c("reward"), sum, na.omit = TRUE)

# Merge
df = merge(sl, ep_rewards, by = c("id", "unique_episode"))

hist(df$remaining_time, 100)

# Test the relationship statistically 
df$remaining_time_z <- scale(df$remaining_time)
m.rew <- lmerTest::lmer(data=df, reward ~ remaining_time_z*group  + (1|blk_number/id))

car::Anova(m.rew)
#em <- emtrends(m.rew, pairwise ~ 1 , var = "remaining_time_z", adjust=adjustment_method)
#em

dost <- 0
if (dost==1) {
  sl<-modelbased::estimate_slopes(m.rew, trend = "remaining_time_z", ci = 0.95)
  sl
  
  # Build relationship sting 
  if (sl$p < 0.001) { 
    p = "p<0.001"} else {
      p = paste0('p=', toString(round(sl$p,4)))
    }
   p_string = paste0('β=', toString(round(sl$Coefficient,2)), ' [',toString(round(sl$CI_low,2)), ', ', toString(round(sl$CI_high,2)), '], ', p )
}
# Average speeding up and reward effects within participant 
df2 <- df %>% 
  group_by(id, group) %>% 
  summarise_at(c("reward", "remaining_time"), mean)
write.csv(df2, here::here("anon-data", "task_data", "speeding_up.csv"))

# Plot
g <- ggplot(aes(y = reward, x = remaining_time), data = df2) +
    geom_point(alpha=0.4, colour="seagreen4") +
    geom_smooth(method = 'lm', se = TRUE, legend=TRUE)  + 
    scale_colour_brewer(palette="Set1")  + 

    ggpubr::stat_cor(method = "spearman",  alternative = "two.sided",  cor.coef.name = c("r"),  label.sep = ", ",  label.x.npc = "left",  label.y.npc = "bottom", digits = 3, r.digits = 3, p.digits = 3) +
   ylab("Reward attained within episode") + 
   xlab("Speeding up effect (positive vals=faster speeding up)") +
   scale_x_continuous(breaks=c(-0.1, 0, 0.1)) + 
   #annotate("text", x = 0, y = 650, label = p_string) + 
      theme(panel.background = element_blank(),  # Ensure background is fully transparent
        panel.grid.major = element_blank(),   # Remove major grid lines
        panel.grid.minor = element_blank(),  
            axis.line = element_line(color = "black"),  # Add axis lines
    axis.ticks = element_line(color = "black"))   # Add axis ticks) +

  print(g)
  


```

### Relating speeding up to reward in each block 

```{r}

linkfunc="log"


m <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group + (1+decay_fac+travel_time_lvl+remaining_time|blk_fac/id), family = Gamma(link=linkfunc))

# Get speeding up effect for each episode (while controlling for other vars)
sl<-data.frame(ranef(m)$cond$`id:blk_fac`)
sl$rawvar <- rownames(sl)
sl <- sl %>%
  tidyr::separate(rawvar, into = c("id", "blk_fac"), sep = ":")

# Get rewards for each episode
ep_rewards <- data %>% 
  group_by(id, group, blk_fac) %>% 
  summarise_at(c("reward"), sum, na.omit = TRUE)

# Merge
df = merge(sl, ep_rewards, by = c("id", "blk_fac"))

hist(df$remaining_time, 100)

# Test the relationship statistically 
df$remaining_time_z <- scale(df$remaining_time)
m.rew <- lmerTest::lmer(data=df, reward ~ remaining_time_z*group*blk_fac  + (1|id))

car::Anova(m.rew)
#em <- emtrends(m.rew, pairwise ~ 1 , var = "remaining_time_z", adjust=adjustment_method)
#em

do_reg <- 0
if (do_reg==1) {
  sl<-modelbased::estimate_slopes(m.rew, trend = "remaining_time_z", ci = 0.95)
  sl
  # Build relationship sting 
  if (sl$p < 0.001) { 
    p = "p<0.001"} else {
      p = paste0('p=', toString(round(sl$p,4)))
    }
   p_string = paste0('β=', toString(round(sl$Coefficient,2)), ' [',toString(round(sl$CI_low,2)), ', ', toString(round(sl$CI_high,2)), '], ', p )
}


# Average speeding up and reward effects within participant 
df2 <- df %>% 
  group_by(id, group) %>% 
  summarise_at(c("reward", "remaining_time"), mean)

write.csv(df2, here::here("anon-data", "task_data", "speeding_up_effect.csv"))


# Plot
g <- ggplot(aes(y = reward, x = remaining_time), data = df2) +
    geom_point(alpha=0.4, colour="seagreen4") +
    geom_smooth(method = 'lm', se = TRUE, legend=TRUE)  + 
    scale_colour_brewer(palette="Set1")  + 

    ggpubr::stat_cor(method = "spearman",  alternative = "two.sided",  cor.coef.name = c("r"),  label.sep = ", ",  label.x.npc = "left",  label.y.npc = "bottom", digits = 3, r.digits = 3, p.digits = 3) +
   ylab("Reward attained within block") + 
   xlab("Speeding up effect (positive vals=faster speeding up)") +
   scale_x_continuous(breaks=c(-0.1, 0, 0.1)) + 
  # annotate("text", x = 0, y = 12000, label = p_string) + 
      theme(panel.background = element_blank(),  # Ensure background is fully transparent
        panel.grid.major = element_blank(),   # Remove major grid lines
        panel.grid.minor = element_blank(),  
            axis.line = element_line(color = "black"),  # Add axis lines
    axis.ticks = element_line(color = "black"))   # Add axis ticks) +

  print(g)
  


```

### Relate speeding up to optimal number of actions
```{r}

linkfunc="log"

m <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group + (1+decay_fac+travel_time_lvl+remaining_time|blk_fac/id), family = Gamma(link=linkfunc))

# Get speeding up effect for each episode (while controlling for other vars)
sl<-data.frame(ranef(m)$cond$`id:blk_fac`)
sl$rawvar <- rownames(sl)
sl <- sl %>%
  tidyr::separate(rawvar, into = c("id", "blk_fac"), sep = ":")

# Get rewards for each episode
ep_rewards <- data %>% 
  group_by(id, group, blk_fac) %>% 
  summarise_at(c("reward"), sum, na.omit = TRUE)

# Merge rewards
df = merge(sl, ep_rewards, by = c("id", "blk_fac"))

# Get disitance from optimal number of actions
ldata <- read.csv(here::here( 'anon-data', 'task_data', 'leaving_time_data.csv'))
ldata$blk_fac <- factor(ldata$blk_number, labels=c(1,2,3,4), ordered=TRUE)
optim_actions <- data.frame(
  travel_time_lvl = c("short", "short", "long", "long"),
  decay_fac = c("slow", "fast", "slow", "fast"),
  optimal_leaving = c(4, 3, 6, 5)
)
ldata <- merge(ldata, optim_actions,  by=c("travel_time_lvl", "decay_fac"))
ldata$optim_dev <- ldata$patch_actions_taken - ldata$optimal_leaving

ep_optim_leaving <- ldata %>% 
  group_by(id, group, blk_fac) %>% 
  summarise_at(c("optim_dev"), mean, na.omit = TRUE)

# Merge optimal leaving
df = merge(sl, ep_optim_leaving[, c("id", "blk_fac", "group", "optim_dev")], by = c("id", "blk_fac"))

hist(df$remaining_time, 100)
hist(df$optim_dev, 100)

# Test the relationship statistically 
df$remaining_time_z <- scale(df$remaining_time)
m.optact <- lmerTest::lmer(data=df, optim_dev ~ remaining_time_z*group  + (1|id))

car::Anova(m.optact)
#em <- emtrends(m.rew, pairwise ~ 1 , var = "remaining_time_z", adjust=adjustment_method)
#em
#sl<-modelbased::estimate_slopes(m.optact, trend = "remaining_time_z", ci = 0.95)
#sl

# Build relationship sting 
if (sl$p < 0.001) { 
  p = "p<0.001"} else {
    p = paste0('p=', toString(round(sl$p,4)))
  }
 p_string = paste0('β=', toString(round(sl$Coefficient,2)), ' [',toString(round(sl$CI_low,2)), ', ', toString(round(sl$CI_high,2)), '], ', p )

# Average speeding up and reward effects within participant 
df2 <- df %>% 
  group_by(id, group) %>% 
  summarise_at(c("optim_dev", "remaining_time"), mean)


# Plot
g <- ggplot(aes(y = optim_dev, x = remaining_time), data = df2) +
    geom_point(alpha=0.4, colour="seagreen4") +
    geom_smooth(method = 'lm', se = TRUE, legend=TRUE)  + 
    scale_colour_brewer(palette="Set1")  + 

  #  ggpubr::stat_cor(method = "pearson",  alternative = "two.sided",  cor.coef.name = c("r"),  label.sep = ", ",  label.x.npc = "left",  label.y.npc = "bottom", digits = 3, r.digits = 3, p.digits = 3) +
   ylab("Deviation from optimal number of actions") + 
   xlab("Speeding up effect (positive vals=faster speeding up)") +
   scale_x_continuous(breaks=c(-0.1, 0, 0.1)) + 
   annotate("text", x = 0, y = 15, label = p_string) + 
      theme(panel.background = element_blank(),  # Ensure background is fully transparent
        panel.grid.major = element_blank(),   # Remove major grid lines
        panel.grid.minor = element_blank(),  
            axis.line = element_line(color = "black"),  # Add axis lines
    axis.ticks = element_line(color = "black"))   # Add axis ticks) +

  print(g)
  
```
# plot by block
```{r fig.width=10, fig.height=4}
# Average speeding up and reward effects within participant by block
df2 <- df %>% 
  group_by(id, group, blk_fac) %>% 
  summarise_at(c("optim_dev", "remaining_time"), mean)


# Plot
g <- ggplot(aes(y = optim_dev, x = remaining_time), data = df2) +
    geom_point(alpha=0.4, colour="seagreen4") +
    geom_smooth(method = 'lm', se = TRUE, legend=TRUE)  + 
    scale_colour_brewer(palette="Set1")  + 

    ggpubr::stat_cor(method = "pearson",  alternative = "two.sided",  cor.coef.name = c("r"),  label.sep = ", ",  label.x.npc = "left",  label.y.npc = "bottom", digits = 3, r.digits = 3, p.digits = 3) +
   ylab("Deviation from optimal number of actions") + 
   xlab("Speeding up effect (positive vals=faster speeding up)") +
   scale_x_continuous(breaks=c(-0.1, 0, 0.1)) + 
   #annotate("text", x = 0, y = 15, label = p_string) + 
      theme(panel.background = element_blank(),  # Ensure background is fully transparent
        panel.grid.major = element_blank(),   # Remove major grid lines
        panel.grid.minor = element_blank(),  
            axis.line = element_line(color = "black"),  # Add axis lines
    axis.ticks = element_line(color = "black"))  +  # Add axis ticks) +
    facet_grid(cols = vars(blk_fac))
  print(g)
  

```

### Speeding up effect and number of actions

```{r}

linkfunc="log"
data$unique_episode <- paste0("bl", data$blk_number, "_ep", data$episode)

m <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group + (1+remaining_time+decay_fac+travel_time_lvl|unique_episode/id), family = Gamma(link=linkfunc))

sl<-data.frame(ranef(m)$cond$`id:unique_episode`)
sl$rawvar <- rownames(sl)
sl <- sl %>%
  tidyr::separate(rawvar, into = c("id", "unique_episode"), sep = ":")

dtf2 <- data[data$decision %in% "leave",]

ep_actions <- dtf2 %>% 
  group_by(id, group,unique_episode, blk_number, episode) %>% 
  summarise_at(c("patch_actions_taken"), sum, na.omit = TRUE)

df = merge(sl, ep_actions, by = c("id", "unique_episode"))

hist(df$remaining_time, 100)


# Test the relationship statistically 
df$remaining_time_z <- scale(df$remaining_time)
m.rew <- lmerTest::lmer(data=df, patch_actions_taken ~ remaining_time_z*group  + (1|blk_number/id))

car::Anova(m.rew)
#em <- emtrends(m.rew, pairwise ~ 1 , var = "remaining_time_z", adjust=adjustment_method)
#em
##sl<-modelbased::estimate_slopes(m.rew, trend = "remaining_time_z", ci = 0.95)
#sl

# Build relationship sting 
if (sl$p < 0.001) { 
  p = "p<0.001"} else {
    p = paste0('p=', toString(round(sl$p,4)))
  }
 p_string = paste0('β=', toString(round(sl$Coefficient,2)), ' [',toString(round(sl$CI_low,2)), ', ', toString(round(sl$CI_high,2)), '], ', p )

 


df2 <- df %>% 
  group_by(id, group) %>% 
  summarise_at(c("patch_actions_taken", "remaining_time"), mean)

g <- ggplot(aes(y = patch_actions_taken, x = remaining_time), data = df2) +
    geom_point(alpha=0.4) +
    geom_smooth(method = 'lm', se = TRUE, legend=TRUE)  + 
    scale_colour_brewer(palette="Set1")  + 
    #ggpubr::stat_cor(method = "pearson",  alternative = "two.sided",  cor.coef.name = c("r"),  label.sep = ", ",  label.x.npc = "left",  label.y.npc = "bottom", digits = 3, r.digits = 3, p.digits = 3) +
   ylab("Number of actions within an episode") + 
   xlab("Speeding up effect (positive vals=faster speeding up)") +
   scale_x_continuous(breaks=c(-0.1, 0, 0.1)) + 
   annotate("text", x = 0, y = 18, label = p_string)
    
  print(g)
  


```

# Also look at reward effects as a consequence of F1

### F1 and reward
```{r fig.width=5, fig.height=5}
ep_rewards <- data %>% 
  group_by(id, group) %>% 
  summarise_at(c("reward"), sum, na.omit = TRUE)
ids <- data %>% 
  group_by(id, group) %>% 
  summarise_at(c("F1", "F2", "F3"), mean, na.omit = TRUE)
dfid = merge(ids, ep_rewards, by = c("id"))


#decay_fac*travel_time_lvl*group + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))

m<-lm(data=dfid, reward ~ F1 )
car::Anova(m)


corrplot::corrplot(cor(dfid[,c("reward", "F1", "F2", "F3")]), method = "number")

g <- ggplot(aes(x = reward, y = F1), data = dfid) +
    geom_point(alpha=0.6, size = 3, color = "purple") +  # Increase dot size and change color
    geom_smooth(method = 'lm', se = TRUE, color = "purple", fill = "purple", alpha = 0.3) +  # Change regression line color, opaque dodgerblue shading
    scale_colour_brewer(palette="Set1") +
    ggpubr::stat_cor(method = "spearman",  alternative = "two.sided", 
                     cor.coef.name = c("r"), label.sep = ", ", 
                     label.x.npc = "left", label.y.npc = "bottom", 
                     digits = 3, r.digits = 3, p.digits = 3,
                     size = 6,  # Make the correlation label bigger
                     label.padding = unit(0.4, "lines"),  # Padding inside the box
                     label.r = unit(0.2, "lines"),  # Rounded corners
                     label.background = element_rect(fill = "white", color = "purple", size = 0.5)) +  # White background, dodgerblue border, rounded edges
    ylab("Factor 1: Eating attitudes") + 
    xlab("Total Reward") + 
    theme(panel.background = element_blank(),  # Ensure background is transparent
          panel.grid.major = element_blank(),   # Remove major grid lines
          panel.grid.minor = element_blank(),
          axis.line = element_line(color = "black"),  # Add axis lines
          axis.ticks = element_line(color = "black"),
          axis.title = element_text(size = 16, color = "black"),  # Increase axis labels size and make text black
          axis.text = element_text(size = 14, color = "black")) +  # Increase tick label size and color to black
    scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +  # Reduce number of x ticks
    scale_y_continuous(breaks = scales::pretty_breaks(n = 4))  # Reduce number of y ticks

print(g)
ggsave(
  here::here("output", "F1_rewards_corr.pdf"), 
  scale = 1,
  width = 5,
  height = 5,
  units = c("in"),
  dpi = 300)
```
## Reward F1 and conditions
```{r}

ep_rewards <- data %>% 
  group_by(id, decay_fac, travel_time_lvl, group) %>% 
  summarise_at(c("reward"), sum, na.omit = TRUE)
ids <- data %>% 
  group_by(id, decay_fac, travel_time_lvl, group) %>% 
  summarise_at(c("F1", "F2", "F3"), mean, na.omit = TRUE)
dfid = merge(ids, ep_rewards, by = c("id", "decay_fac", "travel_time_lvl"))


#decay_fac*travel_time_lvl*group + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))

#m<-lm(data=dfid, reward ~ F1*decay_fac*travel_time_lvl )
m<-lmerTest::lmer(data=dfid, reward ~ F1*decay_fac*travel_time_lvl + (1|id))
car::Anova(m, type="II")


corrplot::corrplot(cor(dfid[,c("reward", "F1", "F2", "F3")]), method = "number")

g <- ggplot(aes(y = reward, x = F1), data = dfid) +
    geom_point(alpha=0.4) +
    geom_smooth(method = 'lm', se = TRUE, legend=TRUE)  + 
    scale_colour_brewer(palette="Set1")  + 
    ggpubr::stat_cor(method = "spearman",  alternative = "two.sided",  cor.coef.name = c("r"),  label.sep = ", ",  label.x.npc = "left",  label.y.npc = "bottom", digits = 3, r.digits = 3, p.digits = 3) +
   ylab("Factor 1: Eating attitudes") + 
   xlab("Reward")  + 
  theme(panel.background = element_blank(),  # Ensure background is fully transparent
        panel.grid.major = element_blank(),   # Remove major grid lines
        panel.grid.minor = element_blank(),  
            axis.line = element_line(color = "black"),  # Add axis lines
    axis.ticks = element_line(color = "black")) + 
  facet_grid(cols = vars(decay_fac), rows = vars(travel_time_lvl))
   #scale_x_continuous(breaks=c(-0.1, 0, 0.1)) 
    
  print(g)

```

### F1 and speeding up 
```{r}

```

### F1, speeding up and reward
```{r fig.width=6, fig.height=6}
linkfunc="log"

m <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl + (1+decay_fac+travel_time_lvl+remaining_time|blk_fac/id), family = Gamma(link=linkfunc))

# Get speeding up effect for each episode (while controlling for other vars)
sl<-data.frame(ranef(m)$cond$`id:blk_fac`)
sl$rawvar <- rownames(sl)
sl <- sl %>%
  tidyr::separate(rawvar, into = c("id", "blk_fac"), sep = ":")

# Get rewards for each episode
ep_rewards <- data %>% 
  group_by(id, group, blk_fac) %>% 
  summarise_at(c("reward"), sum, na.omit = TRUE)

# Merge rewards
df = merge(sl, ep_rewards, by = c("id", "blk_fac"))

# Get disitance from optimal number of actions
ldata <- read.csv(here::here( 'anon-data', 'task_data', 'leaving_time_data.csv'))
ldata$blk_fac <- factor(ldata$blk_number, labels=c(1,2,3,4), ordered=TRUE)
optim_actions <- data.frame(
  travel_time_lvl = c("short", "short", "long", "long"),
  decay_fac = c("slow", "fast", "slow", "fast"),
  optimal_leaving = c(4, 3, 6, 5)
)
ldata <- merge(ldata, optim_actions,  by=c("travel_time_lvl", "decay_fac"))
ldata$optim_dev <- ldata$patch_actions_taken - ldata$optimal_leaving

ep_optim_leaving <- ldata %>% 
  group_by(id, group, blk_fac) %>% 
  summarise_at(c("optim_dev"), mean, na.omit = TRUE)

# Merge optimal leaving
df = merge(sl, ep_optim_leaving[, c("id", "blk_fac", "group", "optim_dev")], by = c("id", "blk_fac"))

# add F1 
ids <- data %>% 
  group_by(id, group) %>% 
  summarise_at(c("F1", "F2", "F3"), mean, na.omit = TRUE)
# Merge ids
df = merge(sl, ids[, c("id", "F1", "F2", "F3")], by = c("id"))

df2 <- df %>% 
  group_by(id) %>% 
  summarise_at(c("F1", "remaining_time"), mean)


df2$remaining_time_reversed <-   df2$remaining_time * (-1)
g <- ggplot(aes(y = F1, x = remaining_time), data = df2) +
    geom_point(alpha=0.6, size = 3, color = "deeppink") +  # Increase dot size and change color
    geom_smooth(method = 'lm', se = TRUE, color = "deeppink", fill = "deeppink", alpha = 0.3) +  # Change regression line color, opaque dodgerblue shading
    scale_colour_brewer(palette="Set1") +
    ggpubr::stat_cor(method = "spearman",  alternative = "two.sided", 
                     cor.coef.name = c("r"), label.sep = ", ", 
                     label.x.npc = "left", label.y.npc = "bottom", 
                     digits = 3, r.digits = 3, p.digits = 3,
                     size = 6,  # Make the correlation label bigger
                     label.padding = unit(0.4, "lines"),  # Padding inside the box
                     label.r = unit(0.2, "lines"),  # Rounded corners
                     label.background = element_rect(fill = "white", color = "deeppink", size = 0.5)) +  # White background, dodgerblue border, rounded edges
   ylab("F1: Eating attitudes") + 
  #scale_x_reverse() +
   xlab("Speeding up effect (positive vals=faster speeding up)") +
    theme(panel.background = element_blank(),  # Ensure background is transparent
          panel.grid.major = element_blank(),   # Remove major grid lines
          panel.grid.minor = element_blank(),
          axis.line = element_line(color = "black"),  # Add axis lines
          axis.ticks = element_line(color = "black"),
          axis.title = element_text(size = 16, color = "black"),  # Increase axis labels size and make text black
          axis.text = element_text(size = 14, color = "black")) +  # Increase tick label size and color to black
    scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +  # Reduce number of x ticks
    scale_y_continuous(breaks = scales::pretty_breaks(n = 4))  # Reduce number of y ticks

print(g)

ggsave(
  here::here("output", "F1_speeding_up_corr_flipped.pdf"), 
  scale = 1,
  width = 5,
  height = 5,
  units = c("in"),
  dpi = 300)
```



### Group by decision
While in Group 2 the RT difference between stay and leave is minimal, in Group 1 leave decisions are faster
 
group2 leave - group2 stay   -0.0799 0.0135 Inf  -5.901  <.0001

```{r}
glm1.sl.2b <- glmmTMB::glmmTMB(data=data, RT ~ decay_fac*travel_time_lvl*group*decision*remaining_time + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))

em <- emmeans(glm1.sl.2b, pairwise ~ group * decision, adjust=adjustment_method)
em

df = data %>%
  group_by(id, decision, group) %>%
  summarise_at(c("logRT"), mean, na.rm = TRUE)

g <- ggplot(data = df, aes(y = logRT, fill = interaction(decision, group), x=decision)) +
  geom_point(aes(color = interaction(decision, group)), position =   position_jitterdodge(  jitter.width = .15,  dodge.width = 0.777
                                                                                                       ), size = 2, lwd=1, alpha = 0.5, show.legend=FALSE) +
  scale_fill_manual(values = c("darkgreen", "darkseagreen", "blue", "lightblue")) + 
  geom_boxplot(inherit.aes = TRUE,  width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=TRUE)   + 
  
  scale_color_manual(values = c("darkgreen", "darkseagreen", "blue", "lightblue")) 
g
```

## Is the "speeding up" effect on RTs best explained by EDs? 

Plots
```{r fig.width=4, fig.height=6}
data$rem_time_q <- gtools::quantcut(as.numeric(data$remaining_time), q = seq(0,1,0.05))
data$F1.ms <- gtools::quantcut(data$F1, q = c(0, 0.5, 1), 
                                 labels = c("low", "high"))
data$F2.ms <- gtools::quantcut(data$F2, q = c(0, 0.5, 1), 
                                 labels = c("low", "high"))
data$F3.ms <- gtools::quantcut(data$F3, q = c(0, 0.5, 1), 
                                 labels = c("low", "high"))

## GROUP
df <- data %>% 
  group_by(id, group,rem_time_q) %>% 
  summarise_at(c("logRT", "remaining_time"), mean)
g <- ggplot(aes(y = logRT, x = remaining_time, color=group), data = df) +
  geom_point(alpha=0.2) +
    geom_smooth(method = 'lm', se = TRUE)  + 
  scale_x_reverse() +
  scale_color_manual(values = rep(c("maroon4","dodgerblue"), 20))  
  #ggtitle("F1 ~ TF1 * wave * Deaths ") 
g


## F1 ED
df <- data %>% 
  group_by(id, F1.ms,rem_time_q) %>% 
  summarise_at(c("logRT", "remaining_time"), mean)
g <- ggplot(aes(y = logRT, x = remaining_time, color=F1.ms), data = df) +
  geom_point(alpha=0.2) +
    geom_smooth(method = 'lm', se = TRUE)  + 
  scale_x_reverse() +
  scale_color_manual(values = rep(c("dodgerblue", "maroon4"), 20))  
  ggtitle("Split by F1") 
g

## F2 Uncertainty
df <- data %>% 
  group_by(id, F2.ms,rem_time_q) %>% 
  summarise_at(c("logRT", "remaining_time"), mean)
g <- ggplot(aes(y = logRT, x = remaining_time, color=F2.ms), data = df) +
  geom_point(alpha=0.2) +
    geom_smooth(method = 'lm', se = TRUE)  + 
  scale_x_reverse() +
  scale_color_manual(values = rep(c("dodgerblue", "maroon4"), 20))  
  ggtitle("Split by F2") 
g

## F3 Anxious Depression
df <- data %>% 
  group_by(id, F3.ms,rem_time_q) %>% 
  summarise_at(c("logRT", "remaining_time"), mean)
g <- ggplot(aes(y = logRT, x = remaining_time, color=F3.ms), data = df) +
  geom_point(alpha=0.2) +
    geom_smooth(method = 'lm', se = TRUE)  + 
  scale_x_reverse() +
  scale_color_manual(values = rep(c("dodgerblue", "maroon4"), 20))  
  ggtitle("Split by F3") 
g
```

## Model comparison for 

```{r}

pm1.sl.g <- glmmTMB::glmmTMB(data=data, formula=RT ~ group*remaining_time + (1|id), family=Gamma(link=linkfunc))
pm1.sl.f1 <- glmmTMB::glmmTMB(data=data, formula=RT ~ F1*remaining_time + (1|id), family=Gamma(link=linkfunc))
pm1.sl.f2 <- glmmTMB::glmmTMB(data=data, formula=RT ~ F2*remaining_time + (1|id), family=Gamma(link=linkfunc))
pm1.sl.f3 <- glmmTMB::glmmTMB(data=data, formula=RT ~ F3*remaining_time + (1|id), family=Gamma(link=linkfunc))

performance::compare_performance(pm1.sl.g, pm1.sl.f1, pm1.sl.f2, pm1.sl.f3)
```

```{r}
car::Anova(pm1.sl.g)
car::Anova(pm1.sl.f1)
car::Anova(pm1.sl.f2)
car::Anova(pm1.sl.f3)

```





# Speeding up effect over time 

```{r}
smod <- glmmTMB::glmmTMB(data=data, RT ~ 1 + (1+remaining_time|blk_number/id), family = Gamma(link=linkfunc))

sl<-data.frame(ranef(smod)$cond$`id:blk_number`)
sl$rawvar <- rownames(sl)
sl <- sl %>%
  separate(rawvar, into = c("id", "blk_number"), sep = ":")


ep_rewards <- data %>% 
  group_by(id, group, blk_number) %>% 
  summarise_at(c("reward"), sum)

df = merge(sl, ep_rewards, by = c("id", "blk_number"))


g <- ggplot(data = df, aes(y = remaining_time, fill = interaction(blk_number, group), x=blk_number)) +
  geom_point(aes(color = interaction(blk_number, group)), position =   position_jitterdodge(  jitter.width = .15,  dodge.width = 0.777
                                                                                                       ), size = 2, lwd=1, alpha = 0.5, show.legend=FALSE) +
  scale_fill_manual(values = c(rep("maroon4",4), rep("dodgerblue",4))) + 
  geom_boxplot(inherit.aes = TRUE,  width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=TRUE)   + 
  
  scale_color_manual(values = c(rep("maroon4",4), rep("dodgerblue",4))) + 
  ylab("Speeding up effect (remaining time slope)")
g


df$blk_number <- paste0("bl", as.factor(df$blk_number))
g <- ggplot(data = df, aes(y = reward, fill = interaction(blk_number, group), x=blk_number)) +
  geom_point(aes(color = interaction(blk_number, group)), position =   position_jitterdodge(  jitter.width = .15,  dodge.width = 0.777
                                                                                                       ), size = 2, lwd=1, alpha = 0.5, show.legend=FALSE) +
  scale_fill_manual(values = c(rep("maroon4",4), rep("dodgerblue",4))) + 
  geom_boxplot(inherit.aes = TRUE,  width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=TRUE)   + 
  
  scale_color_manual(values = c(rep("maroon4",4), rep("dodgerblue",4))) + 
  ylab("Rewards")
g


### How does attained reward relate to slope of speeding up over time? 
m<-lmer(data=df, reward ~ blk_number*remaining_time + (1 |id))
anova(m)
```








# RT effects WITHIN-PATCH

The first trial is very slow so I removed it - the slopes might be too influenced by this. 
I also removed trials after 20 since there were very few of them
```{r}
data2 <- data[data$patch_actions_taken<21 & data$patch_actions_taken>1,]
glm1.sl.1 <- glmmTMB::glmmTMB(data=data2, RT ~ decay_fac*travel_time_lvl*group*decision + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))
glm1.sl.2 <- glmmTMB::glmmTMB(data=data2, RT ~ decay_fac*travel_time_lvl*group*decision*patch_actions_taken + (1+decay_fac+travel_time_lvl|id), family = Gamma(link=linkfunc))
performance::compare_performance( glm1.sl.1, glm1.sl.2)#

```

```{r}
car::Anova(glm1.sl.2)
```

### Speeding up by group within patch

Actually it seems that within patch group1 starts fast but slows down over time to match group 2
```{r}
em <- emtrends(glm1.sl.2, pairwise ~ group , var = "patch_actions_taken", adjust=adjustment_method)
em

df <- data2 %>% 
  group_by(id, group, patch_actions_taken) %>% 
  summarise_at(c( "logRT"), mean)

g <- ggplot(aes(y = logRT, x = patch_actions_taken, fill=interaction(group,patch_actions_taken)), data = df) +
  geom_point(alpha=0.2, aes(color=group), show.legend = FALSE) +
  geom_boxplot( width = .8, lwd=1.2, outlier.shape = NA, alpha = 0.5, show.legend=FALSE)   + 
 #geom_smooth(aes(x = remaining_time, y=logRT), inherit.aes = FALSE, method = lm, formula = y ~ x, se = TRUE, legend=FALSE) +

  scale_fill_manual(values = rep(c("maroon4", "dodgerblue"), 40))  + 
  scale_color_manual(values = rep(c("maroon4","dodgerblue"), 40))  
g
```
```{r fig.width=5, fig.height=7}
df <- data2 %>% 
  group_by(id, group, patch_actions_taken) %>% 
  summarise_at(c("logRT"), mean)

library(ggplot2)
g <- ggplot(aes(y = logRT, x = patch_actions_taken, color=group), data = df) +
  geom_point(alpha=0.2) +
    geom_smooth(method = 'lm', se = TRUE)  + 
  scale_color_manual(values = rep(c("maroon4","dodgerblue"), 20))  
  #ggtitle("F1 ~ TF1 * wave * Deaths ") 
g
```
# Predicting choices

What determines the decision to leave 
- condition (travel time, decay)
- time in patch 
- reward accumulated in patch 
- remaining overall time
- and all these interaction with group

```{r}
correlation_results <- data %>%
  group_by(id) %>%
  summarise(correlation = cor(cum_reward_patch, patch_time, use = "complete.obs"))
hist(correlation_results$correlation)
```




